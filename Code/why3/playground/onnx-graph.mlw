module ONNX_Graph


use int.Int
use list.List
use list.Map
use option.Option
use map.Map
use list.Mem
use list.FoldLeft
use list.Length
use list.NthNoOpt
use map.Const

type value = int


(* A tensor is just an index into a tensor array *)
type tensor = int


(* Graph state: a map of tensor to values with option *)
type graph_state = Map.map tensor (option value)


(* Abstract operator type  *)
type operator


function input_arity (op: operator) : int = 3
function output_arity (op: operator) : int = 2

(* For the moment, we only consider the arity of the operator to check consistency.
In the final version, we have to use a mapping formal parameters => actual tensors
To be replaced by actual operators *)

let input_arity (op: operator) : int = 3
let output_arity (op: operator) : int = 2


(* Map implementation *)
let rec map (f: 'a -> 'b) (l: list 'a) : list 'b
variant { l }
= match l with
    | Nil -> Nil
    | Cons x xs -> Cons (f x) (map f xs)
end

(* Create t list of n elements with the same value x *)
let rec make_list (x: 'a) (n: int) : list 'a
requires { n >= 0 }
ensures{ length result = n}  
ensures{ forall v. mem v result -> v = x }  
variant { n }
= 
    if n = 0 
    then 
        Nil
    else 
        Cons x (make_list x (n - 1))


(* Computes the outputs of an operation  *)
function eval_operator (op: operator) (inputs: list (option value)) : list (option value) 

(* Function modeling the behavior of an operator *)
let eval_operator (op: operator) (inputs: list (option value)) : list (option value) 
requires { length inputs = input_arity op }
requires { output_arity op > 0}
ensures { length result = output_arity op }
=
    (* This is a dummy implementation that return a list of identical values *)
    make_list (Some 0) (output_arity op)


(* An operation is an application of an operator *)
type operation = {
    ope: operator; (* The operator used by the operation *)
    oi: list tensor; (* The input tensors *)
    ou: list tensor; (* The output tensors *)
}

(* A graph is a list of tensors and operations *)
type graph = {
    gi: list tensor; (* Graph inputs *)
    go: list tensor; (* Graph outputs *)
    tensors: list tensor; (* Graph tensors *)
    ops: list operation; (* graph operations *)
}

(* In a given state s, a tensor is initialized if it has some value. *)
predicate is_initialized (s: graph_state) (t: tensor) =
    match Map.get s t with
    | Some _ -> true
    | None -> false
end

(* True if an operation is ready to execute *)
predicate op_ready (s: graph_state) (op: operation) =
    (* An operation is ready if all its inputs tensors are initialized *)
    forall t: tensor. 
        mem t op.oi -> is_initialized s t


(* Define the exception for uninitialized tensors (not used) *)
exception TensorNotInitialized

(* Fold with two parameters *)
let rec fold_left2 (f: 'acc -> 'a -> 'b -> 'acc) (acc: 'acc) (l1: list 'a) (l2: list 'b) : 'acc 
requires { length l1 = length l2 }
variant { l1 }
= match l1, l2 with
| Nil, Nil -> acc
| Cons x xs, Cons y ys -> fold_left2 f (f acc x y) xs ys
| _, _ -> absurd
end

(* Returns the graph state after eeuting one operation *)
let ghost exec_op (s: graph_state) (op: operation) : graph_state
requires { op_ready s op }
requires { length op.oi = input_arity op.ope }
requires { length op.ou = output_arity op.ope } 
ensures {
    (* The result is such that the ouput tensors have the value computed by applying the operator on its inputs tensors *)
    forall i: int. 0 <= i < length op.ou ->
        let input_values = Map.map (fun t -> Map.get s t) op.oi in
            Map.get result (nth i op.ou) = nth i (eval_operator op.ope input_values)
} 
=
    (* the values of tensors that are inputs to an operation *)
    let vals = map (fun t -> Map.get s t) op.oi in 
    (* the values of all outputs after evaluation *)
    let results = eval_operator op.ope vals in 
    (* the updated state *)
    fold_left2 (fun st t v -> Map.set st t v) s op.ou results 

(* Fold implementation with one parameters *)
let rec fold_left (f: 'a -> 'b -> 'a) (acc: 'a) (l: list 'b) : 'a
  variant { l }
= match l with
  | Nil -> acc
  | Cons x xs -> fold_left f (f acc x) xs
  end

(* Initial tensor state: all tensors are undefined *)
let ghost initial_state (g: graph) : graph_state =
    fold_left (fun s t -> Map.set s t None) (Const.const None) g.tensors


(* SSA constraint: a tensor appears in the output of at most one op *)
predicate ssa (g: graph) =
    forall t: tensor.
        length (map (fun op -> mem t op.ou) g.ops) <= 1


(* Each graph input must be used by at least of one op *)
predicate inputs_used (g: graph) =
forall t: tensor.
    mem t g.gi ->
        exists op. mem op g.ops /\ mem t op.oi

(* Each graph output must be produced by one op *)
predicate outputs_defined (g: graph) =
forall t: tensor.
    mem t g.go ->
        exists op. mem op g.ops /\ mem t op.ou

(* Each tensor is either a graph input or is in the output map of at least one operation *)
predicate no_free_tensor (g: graph) =
    forall t: tensor.
        mem t g.tensors ->
            mem t g.gi \/
            exists op. 
                mem op g.ops -> mem t op.ou

(* After execution, all outputs must have values *)
predicate outputs_have_values (g: graph) (s: graph_state) =
forall t.
    mem t g.go ->
    is_initialized s t


end













