module Graph


use int.Int
use list.List
use list.Map
use option.Option
use map.Map
use list.Mem
use list.FoldLeft
use list.Length
use list.NthNoOpt
use map.Const
use bool.Bool

(* A tensor value is just an int *)
type value = int


(* A tensor is just an index into a tensor array *)
type tensor = int


(* Graph state: a map of tensor to values with option *)
type graph_state = Map.map tensor (option value)


(* Abstract operator type  *)
type operator



(* ------------------------------------------------------------------------- *)

  (* === Executable finite map === *)
  type fmap = list (tensor, option value)

function fget_logic (m: list (tensor, option value)) (k: tensor) : option value =
  match m with
  | Nil -> None
  | Cons (k', v) tl -> if k = k' then v else fget_logic tl k
  end


  let rec fget (m: fmap) (k: tensor) : option value =
  ensures { result = fget_logic m k}
  variant { m }
    match m with
    | Nil -> None
    | Cons (k', v) tl -> if k = k' then v else fget tl k
    end


  function fset_logic (m: fmap) (k: tensor) (v: option value) : fmap =
    match m with
    | Nil -> Cons (k, v) Nil
    | Cons (k', v') tl ->
        if k = k' then Cons (k, v) tl
        else Cons (k', v') (fset_logic tl k v)
    end

  let rec fset (m: fmap) (k: tensor) (v: option value) : fmap =
  ensures { result = fset_logic m k v}
  
  variant { m }
    match m with
    | Nil -> Cons (k, v) Nil
    | Cons (k', v') tl ->
        if k = k' then Cons (k, v) tl
        else Cons (k', v') (fset tl k v)
    end


  (* === Logical projection from fmap to abstract map === *)
  function as_spec (m: fmap): Map.map tensor (option value) =
    fun k -> fget_logic m k 

    
  lemma get_set_eq:
    forall m: fmap, k: tensor, v: option value.
      fget_logic (fset_logic m k v) k = v

  lemma get_set_neq:
    forall m: fmap, k1 k2: tensor, v: option value.
      k1 <> k2 ->
      fget_logic (fset_logic m k2 v) k1 = fget_logic m k1



(* My get function behaves as the spec. *)
  lemma as_spec_get:
    forall m: fmap, k: tensor.
      match fget_logic m k with
      | Some v -> Map.get (as_spec m) k = Some(v)
      | None -> true
      end

(* Link set function behaves as the spec *)
  lemma as_spec_set:
    forall m: fmap, k: tensor, v: option value.
      as_spec (fset_logic m k v) = Map.set (as_spec m) k v



 (* --------------------------------------------------------------------------- *)
 

function input_arity (_: operator) : int = 3
function output_arity (_: operator) : int = 2

(* For the moment, we only consider the arity of the operator to check consistency.
In the final version, we have to use a mapping formal parameters => actual tensors
To be replaced by actual operators *)

let input_arity (_: operator) : int = 3
let output_arity (_: operator) : int = 2


(* Map implementation *)
let rec map (f: 'a -> 'b) (l: list 'a) : list 'b
ensures { length result = length l }
variant { l }
= match l with
    | Nil -> Nil
    | Cons x xs -> Cons (f x) (map f xs)
end

(* Create t list of n elements with the same value x *)
let rec make_list (x: 'a) (n: int) : list 'a
requires { n >= 0 }
ensures{ length result = n}  
ensures{ forall v. mem v result -> v = x }  
variant { n }
= 
    if n = 0 
    then 
        Nil
    else 
        Cons x (make_list x (n - 1))

(* Fold implementation with one parameters *)
let rec fold_left (f: 'a -> 'b -> 'a) (acc: 'a) (l: list 'b) : 'a
  variant { l }
= match l with
  | Nil -> acc
  | Cons x xs -> fold_left f (f acc x) xs
  end

(* Computes the outputs of an operation  *)
function eval_operator (op: operator) (inputs: list (option value)) : list (option value) 

(* Function modeling the behavior of an operator *)
let eval_operator (op: operator) (inputs: list (option value)) : list (option value) 
requires { length inputs = input_arity op }
requires { output_arity op > 0}
(* All outputs are initialized *)
ensures { forall i. mem i result -> i <> None } 

ensures { length result = output_arity op } (* There is one value per output tensor *)
=
    (* This is a dummy implementation that return a list of identical values *)
    make_list (Some 0) (output_arity op)


(* An operation is an application of an operator *)
type operation = {
    ope: operator; (* The operator used by the operation *)
    oi: list tensor; (* The input tensors *)
    ou: list tensor; (* The output tensors *)
}

(* A graph is a list of tensors and operations *)
type graph = {
    gi: list tensor; (* Graph inputs *)
    go: list tensor; (* Graph outputs *)
    tensors: list tensor; (* Graph tensors *)
    ops: list operation; (* graph operations *)
}

(* ------------------------------------------------------------------------- *)    
(* True if a tensor t is initialized in state s. *)
(* ------------------------------------------------------------------------- *)    
predicate is_initialized (s: graph_state) (t: tensor) =
    match Map.get s t with
    | Some _ -> true
    | None -> false
end

(* ------------------------------------------------------------------------- *)    
(* True if a tensor t is initialized in state s. *)
(* ------------------------------------------------------------------------- *)    
let is_initialized (s: graph_state) (t: tensor) : bool 
ensures { result = is_initialized s t }
=
    match Map.get s t with
    | Some _ -> true
    | None -> false
    end

(* ------------------------------------------------------------------------- *)    
(* True if operation op is executable in state s *)
(* ------------------------------------------------------------------------- *)    
predicate op_ready (s: graph_state) (op: operation) =
    (* An operation is ready if all its inputs tensors are initialized *)
    forall t: tensor. 
        mem t op.oi -> is_initialized s t


(* ------------------------------------------------------------------------- *)
(* Essai pour aider le prouveur... *)
(* ------------------------------------------------------------------------- *)

predicate all_init (s: graph_state) (l: list tensor) = 
    forall t: tensor. mem t l -> is_initialized s t
    
function f (s: graph_state) (acc: bool)  (t: tensor) : bool =
  acc && is_initialized s t

let  f (s: graph_state) (acc: bool)  (t: tensor) : bool =
  acc && is_initialized s t

lemma preservation :
    forall acc: bool, l: list tensor, s: graph_state. 
    acc -> 
        match l with
        | Nil -> true
        | Cons x xs -> (f s) true x /\ all_init s xs
        end


(* ------------------------------------------------------------------------- *)
(* Test simple : Ã©chec de la preuve *)
(* ------------------------------------------------------------------------- *)
predicate all_true (l: list bool)  = forall b: bool. mem b l -> b = true

       
axiom fold_left_and_equiv_all_true:
  forall l: list bool.
    fold_left Bool.andb true l = true <-> all_true l
    
(* ------------------------------------------------------------------------- *)    
(* True if operation op is executable in state s *)
(* ------------------------------------------------------------------------- *)    
(* Note that the ensures clause only states that the result is true if the operation is ready. 
   It does not state that the result is false if the operation is not ready. *)
let op_ready (s: graph_state) (op: operation) : bool
ensures { result = true -> op_ready s op } 
=
    (* An operation is ready if all its inputs tensors are initialized *)
    fold_left  (f s) true op.oi 
        

(* Define the exception for uninitialized tensors (not used) *)
exception TensorNotInitialized

(* ------------------------------------------------------------------------- *)    
(* Fold with two parameters *)
(* ------------------------------------------------------------------------- *)    
let rec fold_left2 (f: 'acc -> 'a -> 'b -> 'acc) (acc: 'acc) (l1: list 'a) (l2: list 'b) : 'acc 
requires { length l1 = length l2 }
variant { l1 }
= match l1, l2 with
| Nil, Nil -> acc
| Cons x xs, Cons y ys -> fold_left2 f (f acc x y) xs ys
| _, _ -> absurd
end



(* ------------------------------------------------------------------------- *)    
(* Introduced to set the value of a tensor in the graph state *)
(* ------------------------------------------------------------------------- *)    
let ghost myset2 (s: graph_state)(t)(v) : graph_state 
    (* The value of the tensor is set to v in the state st *)
    (* The tensor is initialized after the operation *)
    requires { 
        v <> None
    }
    ensures { 
        is_initialized result t
    }
    =
    set s t v

(* ------------------------------------------------------------------------- *)    
(* Returns the graph state after executing one operation *)
(* ------------------------------------------------------------------------- *)    
let ghost exec_op (s: graph_state) (op: operation) : graph_state
requires { op_ready s op }
requires { length op.oi = input_arity op.ope }
requires { length op.ou = output_arity op.ope } 
    (* All output tensors are set *)
ensures { 
    forall t: tensor. 
        mem t op.ou -> is_initialized result t
}
=
    (* the values of tensors that are inputs to an operation *)
    let inputs = map (fun t -> Map.get s t) op.oi in 
        assert { forall v.  mem v inputs -> v <> None  };
    (* the values of all outputs after evaluation *)
    let outputs = eval_operator op.ope inputs in 
        assert { forall v.  mem v outputs -> v <> None  };
        (* the updated state *)
        fold_left2 (myset2) s op.ou outputs 

(* ------------------------------------------------------------------------- *)    
(* All input tensors are initialized *)
(* ------------------------------------------------------------------------- *)    
predicate input_initialized (g: graph) (s: graph_state) =
forall t.
    mem t g.gi ->
    is_initialized s t

(* ------------------------------------------------------------------------- *)    
(* All output tensors are initialized *)
(* ------------------------------------------------------------------------- *)    
predicate outputs_initialized (g: graph) (s: graph_state) =
forall t.
    mem t g.go ->
    is_initialized s t

(* ------------------------------------------------------------------------- *)    
(*  Execute the complete graph. 
    Returns the graph state after executing all operations in the graph 
    The next operation to be executed is chosen non deterministically among the executable operations *)
(* ------------------------------------------------------------------------- *)    
let exec_graph (s: graph_state) (g: graph) : graph_state 
    requires { input_initialized g s} 
    ensures { outputs_initialized g result}
    = 
    let executable_ops = map (fun o -> op_ready s o) g.ops in 
    s (* dummy implementation *)


(* ------------------------------------------------------------------------- *)    
(* Initial tensor state: all tensors are undefined *)
(* ------------------------------------------------------------------------- *)    
let ghost set_initial_state (g: graph) : graph_state =
    fold_left (fun s t -> Map.set s t None) (Const.const None) g.tensors

(* ------------------------------------------------------------------------- *)    
(* SSA constraint: a tensor appears in the output of at most one op *)
(* ------------------------------------------------------------------------- *)    
predicate ssa (g: graph) =
    forall t: tensor.
        length (map (fun op -> mem t op.ou) g.ops) <= 1

(* ------------------------------------------------------------------------- *)    
(* Each graph input must be used by at least of one op *)
(* ------------------------------------------------------------------------- *)    
predicate inputs_used (g: graph) =
forall t: tensor.
    mem t g.gi ->
        exists op. mem op g.ops /\ mem t op.oi

(* ------------------------------------------------------------------------- *)    
(* Each graph output must be produced by one op *)
(* ------------------------------------------------------------------------- *)    
predicate outputs_defined (g: graph) =
forall t: tensor.
    mem t g.go ->
        exists op. mem op g.ops /\ mem t op.ou

(* ------------------------------------------------------------------------- *)    
(* Each tensor is either a graph input or is in the output map of at least one operation *)
(* ------------------------------------------------------------------------- *)    
predicate no_free_tensor (g: graph) =
    forall t: tensor.
        mem t g.tensors ->
            mem t g.gi \/
            exists op. 
                not mem op g.ops \/ mem t op.ou




end













