;;; this is a prelude for Alt-Ergo, Dolmen frontend
(set-logic ALL)
(set-info :smt-lib-version 2.6)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2: integer arithmetic
(declare-sort list 1)

;; "Nil"
(declare-fun Nil (par (a)
  () (list a)))

;; "Cons"
(declare-fun Cons (par (a)
  (a
  (list a)) (list a)))

;; "match_list"
(declare-fun match_list (par (a
  a1)
  ((list a)
  a1
  a1) a1))

;; "match_list_Nil"
(assert (par (a a1)
  (forall ((z a1) (z1 a1)) (= (match_list (as Nil (list a)) z z1) z))))

;; "match_list_Cons"
(assert (par (a a1)
  (forall ((z a1) (z1 a1) (u a) (u1 (list a)))
    (= (match_list (Cons u u1) z z1) z1))))

;; "index_list"
(declare-fun index_list (par (a)
  ((list a)) Int))

;; "index_list_Nil"
(assert (par (a) (= (index_list (as Nil (list a))) 0)))

;; "index_list_Cons"
(assert (par (a)
  (forall ((u a) (u1 (list a)))
    (! (= (index_list (Cons u u1)) 1) :pattern ((Cons u u1)) ))))

;; "Cons_proj_1"
(declare-fun Cons_proj_1 (par (a)
  ((list a)) a))

;; "Cons_proj_1'def"
(assert (par (a)
  (forall ((u a) (u1 (list a))) (= (Cons_proj_1 (Cons u u1)) u))))

;; "Cons_proj_2"
(declare-fun Cons_proj_2 (par (a)
  ((list a)) (list a)))

;; "Cons_proj_2'def"
(assert (par (a)
  (forall ((u a) (u1 (list a))) (= (Cons_proj_2 (Cons u u1)) u1))))

;; "list_inversion"
(assert (par (a)
  (forall ((u (list a)))
    (or (= u (as Nil (list a))) (= u (Cons (Cons_proj_1 u) (Cons_proj_2 u)))))))

(declare-sort option 1)

;; "None"
(declare-fun None (par (a)
  () (option a)))

;; "Some"
(declare-fun Some (par (a)
  (a) (option a)))

;; "match_option"
(declare-fun match_option (par (a
  a2)
  ((option a)
  a2
  a2) a2))

;; "match_option_None"
(assert (par (a a2)
  (forall ((z a2) (z1 a2)) (= (match_option (as None (option a)) z z1) z))))

;; "match_option_Some"
(assert (par (a a2)
  (forall ((z a2) (z1 a2) (u a)) (= (match_option (Some u) z z1) z1))))

;; "index_option"
(declare-fun index_option (par (a)
  ((option a)) Int))

;; "index_option_None"
(assert (par (a) (= (index_option (as None (option a))) 0)))

;; "index_option_Some"
(assert (par (a)
  (forall ((u a)) (! (= (index_option (Some u)) 1) :pattern ((Some u)) ))))

;; "Some_proj_1"
(declare-fun Some_proj_1 (par (a)
  ((option a)) a))

;; "Some_proj_1'def"
(assert (par (a) (forall ((u a)) (= (Some_proj_1 (Some u)) u))))

;; "option_inversion"
(assert (par (a)
  (forall ((u (option a)))
    (or (= u (as None (option a))) (= u (Some (Some_proj_1 u)))))))

;; "mem"
(declare-fun mem (par (a)
  (a
  (list a)) Bool))

;; "mem'def"
(assert (par (a) (forall ((x a)) (not (mem x (as Nil (list a)))))))

;; "mem'def"
(assert (par (a)
  (forall ((x a))
    (forall ((y a) (r (list a)))
      (=> (mem x (Cons y r)) (or (= x y) (mem x r)))))))

;; "mem'def"
(assert (par (a)
  (forall ((x a))
    (forall ((y a) (r (list a)))
      (=> (or (= x y) (mem x r)) (mem x (Cons y r)))))))

;; "fold_left"
(declare-fun fold_left (par (a
  b)
  ((Array b (Array a b))
  b
  (list a)) b))

;; "fold_left'def"
(assert (par (a b)
  (forall ((f (Array b (Array a b))) (acc b))
    (= (fold_left f acc (as Nil (list a))) acc))))

;; "fold_left'def"
(assert (par (a b)
  (forall ((f (Array b (Array a b))) (acc b))
    (forall ((x a) (r (list a)))
      (= (fold_left f acc (Cons x r)) (fold_left
                                        f
                                        (select (select f acc) x)
                                        r))))))

;; "infix ++"
(declare-fun infix_plpl (par (a)
  ((list a)
  (list a)) (list a)))

;; "infix ++'def"
(assert (par (a)
  (forall ((l2 (list a))) (= (infix_plpl (as Nil (list a)) l2) l2))))

;; "infix ++'def"
(assert (par (a)
  (forall ((l2 (list a)))
    (forall ((x1 a) (r1 (list a)))
      (= (infix_plpl (Cons x1 r1) l2) (Cons x1 (infix_plpl r1 l2)))))))

;; "Append_assoc"
(assert (par (a)
  (forall ((l1 (list a)) (l2 (list a)) (l3 (list a)))
    (= (infix_plpl l1 (infix_plpl l2 l3)) (infix_plpl (infix_plpl l1 l2) l3)))))

;; "Append_l_nil"
(assert (par (a)
  (forall ((l (list a))) (= (infix_plpl l (as Nil (list a))) l))))

;; "length"
(declare-fun length (par (a)
  ((list a)) Int))

;; "length'def"
(assert (par (a) (= (length (as Nil (list a))) 0)))

;; "length'def"
(assert (par (a)
  (forall ((x a) (x1 (list a))) (= (length (Cons x x1)) (+ 1 (length x1))))))

;; "Length_nonnegative"
(assert (par (a) (forall ((l (list a))) (<= 0 (length l)))))

;; "Length_nil"
(assert (par (a)
  (forall ((l (list a))) (=> (= (length l) 0) (= l (as Nil (list a)))))))

;; "Length_nil"
(assert (par (a)
  (forall ((l (list a))) (=> (= l (as Nil (list a))) (= (length l) 0)))))

;; "Append_length"
(assert (par (a)
  (forall ((l1 (list a)) (l2 (list a)))
    (= (length (infix_plpl l1 l2)) (+ (length l1) (length l2))))))

;; "mem_append"
(assert (par (a)
  (forall ((x a) (l1 (list a)) (l2 (list a)))
    (=> (mem x (infix_plpl l1 l2)) (or (mem x l1) (mem x l2))))))

;; "mem_append"
(assert (par (a)
  (forall ((x a) (l1 (list a)) (l2 (list a)))
    (=> (or (mem x l1) (mem x l2)) (mem x (infix_plpl l1 l2))))))

;; "mem_decomp"
(assert (par (a)
  (forall ((x a) (l (list a)))
    (=>
      (mem x l)
      (exists ((l1 (list a)) (l2 (list a)))
        (= l (infix_plpl l1 (Cons x l2))))))))

;; "fold_left_append"
(assert (par (a b)
  (forall ((l1 (list a)) (l2 (list a)) (f (Array b (Array a b))) (acc b))
    (= (fold_left f acc (infix_plpl l1 l2)) (fold_left
                                              f
                                              (fold_left f acc l1)
                                              l2)))))

;; "nth"
(declare-fun nth (par (a)
  (Int
  (list a)) a))

;; "nth_cons_0"
(assert (par (a) (forall ((x a) (r (list a))) (= (nth 0 (Cons x r)) x))))

;; "nth_cons_n"
(assert (par (a)
  (forall ((x a) (r (list a)) (n Int))
    (=> (< 0 n) (= (nth n (Cons x r)) (nth (- n 1) r))))))

(declare-sort operator 0)

(declare-datatypes ((operation 0))
  (((operationqtmk (ope operator)(oi (list Int))(ou (list Int))))))

;; "is_initialized"
(define-fun is_initialized ((s (Array Int (option Int))) (t Int)) Bool
  (not (= (select s t) (as None (option Int)))))

;; "op_ready"
(define-fun op_ready ((s (Array Int (option Int))) (op operation)) Bool
  (forall ((t Int)) (=> (mem t (oi op)) (is_initialized s t))))

;; "s"
(declare-fun s () (Array Int (option Int)))

;; "op"
(declare-fun op () operation)

;; "Requires"
(assert (op_ready s op))

;; "Requires"
(assert (= (length (oi op)) 3))

;; "Requires"
(assert (= (length (ou op)) 2))

;; "inputs"
(declare-fun inputs () (list (option Int)))

;; "Ensures"
(assert (= (length inputs) (length (oi op))))

;; "Assert"
(assert
  (forall ((v (option Int)))
    (=> (mem v inputs) (not (= v (as None (option Int)))))))

;; Goal "exec_op'vc"
;; File "/home/eric/Work/Work/Code/why3/onnxgraph.mlw", line 137, characters 10-17
(assert
  (not (= (length inputs) 3)))

(check-sat)
